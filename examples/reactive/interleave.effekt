module reactive/interleave

import immutable/option
import reactive/types
import reactive/effects

def asyncTask{task: => Unit / Async}: Unit / {Async, PollEvents} = {
    var p = fun(){()}
    p = fun() {
        try {
            task()
            do done()
        } with Async {
            def await() = p = fun(){ resume(Base()) }
            def done() = do done()
        }
    }

    def loop(): Unit = {
        do await()
        p()
        loop()
    }

    loop()
}

def interleave{ task1: => Unit / Async} { task2: => Unit / Async }: Unit / Async = {
    var p1 = fun(){()}
    var p2 = fun(){()}

    p1 = fun(){ try {
        task1()
        do done()
        } with Async {
            def await() = p1 = fun(){ resume(Base()) }
            def done() = do done()
        }
    }

    p2 = fun(){ try {
        task2()
        do done()
        } with Async {
            def await() = p2 = fun(){ resume(Base()) }
            def done() = do done()
        }
    }

    def loop(): Unit = {
        do await()
        p1()
        p2()
        loop()
    }
    loop()
}

def bothHaveTerm{ task1: => Unit / Async } { task2: => Unit / Async }: Unit / Async = {
    var oneHasFinished = false;
    try {
        interleave{task1}{task2}
    } with Async {
        def await() = resume(do await())
        def done() = if(oneHasFinished){do done()} else {oneHasFinished = true; resume(())}
    }
}

def oneOfTerm{ task1: => Unit / Async } {task2: => Unit / Async }: Unit / Async = try {
   interleave{task1}{task2}
} with Async {
    def await() = resume(do await())
    def done() = do done()
}

def run{f: => Unit / {Async}}: Unit = {
    try{
        f()
    } with Async {
        def await() = resume(Base())
        def done() = ()
    }
}
