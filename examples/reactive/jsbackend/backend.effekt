module reactive/jsbackend/backend
import reactive/types

extern include "./backend.js"

extern type JSTimer
extern type JSInput
extern type JSObservable
extern type JSEvent

extern io def createTimer(): JSTimer = "new Timer()"

extern io def createInput(): JSInput = "new Input()"

extern io def toObservable(t: JSTimer): JSObservable = "t"

extern io def toObservable(i: JSInput): JSObservable = "i"

extern io def getEvent(timer: JSObservable, id: Int): JSEvent = "timer.getEvent(id)"

extern io def ex_onInput(input: JSInput): Int = "input.onInput()"

extern io def ex_waitFor(timer: JSTimer, ms: Int): Int = "timer.waitFor(ms)"

extern pure def getStatus(e: JSEvent): String = "e.status"

extern pure def getData[A](e: JSEvent): A = "e.data"

extern pure def getType(e: JSEvent): String = "e.type"

def poll(event: JSEvent): Option[EventData] = {
    val status = event.getStatus()

    if(status == "fullfilled") {
        val d_type = event.getType()
       
        if(d_type == "int"){
            Some(IntData(event.getData()))
         }else if(d_type == "string"){
            Some(StringData(event.getData()))
         } 
        else {
            Some(Error("Unkown Datatype. JS Backend corrupted."))
        }
    } else if(status == "error") {
        val data = event.getData[String]()
        Some(Error(data))
    } else {
        None()
    }
}

def waitFor(timer: JSTimer, ms: Int): Poll = {
    val id = ex_waitFor(timer, ms)
    fun(){ timer.toObservable().getEvent(id).poll() }
}

def onInput(input: JSInput): Poll = {
    val id = ex_onInput(input)
    fun(){input.toObservable().getEvent(id).poll()}
}