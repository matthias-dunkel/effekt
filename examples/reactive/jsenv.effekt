module reactive/jsenv
import immutable/list
import immutable/dequeue
import reactive/reactive

extern include "jsenv.js"

extern type JSEnv

extern type JSEvent

extern type JSArray

effect getJSEnv(): JSEnv

extern pure def ex_exampleArray(): JSArray = "[1,2,3,4,5,6]"

extern pure def ex_length(array: JSArray): Int = "array.length"

extern pure def ex_getAt[JSA](array: JSArray, i: Int): JSA = "array[i]"

def toList[JSA, B](array: JSArray){deserializeElements: JSA => B}: List[B] = {
    var list = []
    var index: Int = 0
    var size = array.ex_length()
    while(index < size){
        list = list.append(
            [deserializeElements(
                array.ex_getAt(index)
                )
            ]
            )
        index = index + 1
    }

    list
}

extern io def ex_nextIteration[A]{f: => A}: Unit = "setTimeout(() => f().run(), 0)"

extern pure def ex_createEnv(): JSEnv = "new JSEnv()"

extern pure def ex_pollJSEvents(env: JSEnv): JSArray = "env.pollEvents()"

extern pure def ex_getEventId(event: JSEvent): String = "event.id"

extern pure def ex_getEventData[A](event: JSEvent): A = "event.data"

extern pure def ex_getEventType(event: JSEvent): String = "event.type"

extern io def ex_waitFor(env: JSEnv,t: Int): String = "env.waitFor(t)"

def waitFor(t: Int) = do getJSEnv().ex_waitFor(t)

extern io def ex_question(env: JSEnv, prompt: String): String = "env.question(question)"

def question(prompt: String) = do getJSEnv().ex_question(prompt)

// Effekt related

def toEvent(event: JSEvent): Event = {
    val eventType = event.ex_getEventType()
    
    if(eventType == "question") {
        Event(event.ex_getEventId(), StringData(event.ex_getEventData()))
    } else {
        Event(event.ex_getEventId(), Base())
    }
} 

def pollEvents(env: JSEnv): Dequeue[Event] =  {
        var events = ex_pollJSEvents(env).toList{ toEvent }
        Dequeue(events, events.size, [], 0)
}

// Dequeue Helper
def append[R](dq1: Dequeue[R], dq2: Dequeue[R]): Dequeue[R] = dq1 match {
    case Dequeue(f1, fs1, r1, rs1) => 
        dq2 match {
            case Dequeue(f2, fs2, r2, rs2) => 
                Dequeue(f1.append(f2), fs1 + fs2, r1.append(r2), rs1 + rs2)
        }
}


def withJSEnv{ f: => Unit / {Poll, Tick, getJSEnv} } = {
    val jsenv = ex_createEnv()
    try {
        f()
    } with Poll {
        def poll() = resume(jsenv.pollEvents().append(do poll()))
    } with Tick {
        def nextTick() = {
            do nextTick()
            ex_nextIteration{ resume(()) }
        }
    } with getJSEnv {
        def getJSEnv() = resume(jsenv)
    }
}