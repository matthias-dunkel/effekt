module reactive/reactive
import immutable/list
import immutable/dequeue
import immutable/option

type EventData {
    Base()
    StringData(data: String)
    IntData(data: Int)
}

def isBaseData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def isStringData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def isIntData(event: EventData): Boolean = event match {
    case IntData(d) => true
    case ev => false
}

extern pure def JStoString(number: Int): String = "toString(number)"
def unsafeToString(event: EventData): String = event match {
    case StringData(d) => d
    case ev => ""
}

extern pure def JSparseInt(string: String): Int = "parseInt(string)"

def unsafeToInt(event: EventData): Int = event match {
    case IntData(d) => d
    case StringData(d) => JSparseInt(d)
    case ev => 0
}

record Event(id: String, data: EventData)

type Coroutine {
    Done()
    More(f: Event => Coroutine at {global, io})
}

effect Wait {
    def wait(event: String): EventData 
}

def single(task: => Unit / {Wait} at {global, io}): Coroutine = {
    try {
        task();
        Done()
    } with Wait {
        def wait(event) = {
            var cr in global = Done()
            cr = More(
                fun(_event: Event){
                    if(event == _event.id){
                        resume(_event.data)
                    }else{
                        cr
                    }
                }
            )
            cr
         } 
    }
}

def parOr(task1: Coroutine, task2: Coroutine): Coroutine = {
    (task1, task2) match {
        case (More(f1), More(f2)) => More(
            fun(event: Event){
                parOr(f1(event), f2(event))
            }
        )
        case (t1, t2) => Done() 
    }
}

def parAnd(task1: Coroutine, task2: Coroutine): Coroutine = {
   (task1, task2) match {
        case (Done(), Done()) => Done()
        case (More(f1), More(f2)) => More(
            fun(event: Event){
                parAnd(f1(event), f2(event))
            }
        )

        case (Done(), More(f)) => More(
            fun(event: Event){
                parAnd(Done(), f(event))
            }
        )

        case (More(f), Done()) => More(
            fun(event: Event){
                parAnd(f(event), Done() )
            }
        )
    }
}

extern io def nextIteration[A]{f: => A }: Unit = "setTimeout(() => f().run(), 0)"

def eventLoop (task: Coroutine, poll: => Dequeue[Event] at {global, io}): Unit / {} = {
    def helper(q: Dequeue[Event], task_: Coroutine): Unit = {
        (q.popFront(), task_) match {
            case (None(), Done()) => ()
            case (Some((e, rest)), Done()) => ()
            case (None(), More(f)) => nextIteration{eventLoop(More(f), poll)}
            case (Some((e, rest)), More(f)) => helper(rest, f(e)) 
        }
    }
    
    task match {
        case Done() => ()
        case t => helper(poll(), t)
    }
}

