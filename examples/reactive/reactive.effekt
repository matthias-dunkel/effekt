module reactive/reactive
import immutable/list
import immutable/dequeue
import immutable/option

type EventData {
    Base()
}

record Event(id: String, data: EventData)

type Trail {
    Terminated()
    Single(event: String, res: EventData => Unit at {})
    ParOr(firstTrail: Trail, secondTrail: Trail)
    ParAnd(firstTrail: Trail, secondTrail: Trail)
}

effect Wait {
    def wait(event: String): EventData 
}

effect Emit {
    def emit(event: Event): Unit
}

def single{trail: => Unit / {Wait, Emit}}: Trail / Emit = {
    var t: Trail = Terminated()
    try {
        region TrailRegion trail()
    } with Wait {
        def wait(event) = region WaitRegion { t = Single(event, resume) }
    }
    t
}

def parOr{firstTrail: => Unit / {Wait, Emit}}{secondTrail: => Unit / {Wait, Emit}}: Trail / Emit  = {
    var t1 = single{firstTrail};
    var t2 = single{secondTrail};

    if(t1 != Terminated() && t2 != Terminated()){
        ParOr(t1, t2)
    } else {
        Terminated()
    }
}

def parAnd{firstTrail: => Unit / {Wait, Emit}}{secondTrail: => Unit / {Wait, Emit}}: Trail / Emit  = {
    var t1 = single{firstTrail};
    var t2 = single{secondTrail};

    if(t1 != Terminated() || t2 != Terminated()){
        ParAnd(t1, t2)
    } else {
        Terminated()
    }
}

def eventHandler(t: Trail, event: Event): Trail / Emit  = {
    var eventId = event.id;
    var eventData = event.data;
    t match {
        case Terminated() => Terminated()
        
        case Single(eventId, res) => single{ res(eventData) }
        
        case ParOr(Terminated(), secondTrail) => Terminated()
        case ParOr(firstTrail, Terminated()) => Terminated()
        case ParOr(firstTrail, secondTrail) => ParOr(
                                                    firstTrail.eventHandler(event),
                                                    secondTrail.eventHandler(event)
                                                    )
        
        case ParAnd(Terminated(), Terminated()) => Terminated()
        case ParAnd(firstTrail, secondTrail) => ParAnd(
                                                    firstTrail.eventHandler(event), 
                                                    secondTrail.eventHandler(event)
                                                    )                                                 
    }
}


def eventLoop{t: => Trail / Emit }: Unit / {} = {
    extern io def nextIteration[A]{f: => A }: Unit = "setTimeout(f, 0)"

    var eventQueue: Dequeue[Event] = emptyQueue()
    try {
        var trail = t();
        
        def helper(): Unit = {
            if(trail != Terminated() && not(eventQueue.isEmpty())) {
                var popped = eventQueue.popFront()
                popped match {
                    case None() => ()
                    case Some((e, q)) => 
                        eventQueue = q;
                        trail = trail.eventHandler(e)
                    }
                nextIteration{helper()}
            }
        }

        helper()
    } 
    with Emit {
        def emit(event: Event) = {
            eventQueue = eventQueue.pushBack(event);
            resume(())
        }
    }    
}

def example1(): Unit / {} = {
    println("Example 1: Single Trail Only")
    eventLoop{
            single{
            println("Waiting for Event 1")
            do wait("1")
            println("Event 1 Happened")
        }
    }
}

def example2(): Unit / {} = {
    println("Example 2: ParOr with Single Trails")
    eventLoop{
       parOr{
            println("Trail1: Waiting for Event 1")
            do wait("1")
            println("Trail1: Event 1 Happened")
            println("Trail1: Emit Event 2")
            do emit(Event("2", Base()))
            
       } {  
            println("Trail2: Emit Event 1")
            do emit(Event("1", Base()))
            println("Trail2: Waiting for Event 2")
            do wait("2")
            println("Trail2: Event 2 Happened")
       }
    }
}

def main() = {
    //example1()
    example2()
}