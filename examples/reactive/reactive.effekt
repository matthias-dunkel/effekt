module reactive/reactive
import immutable/list
import immutable/dequeue
import immutable/option

import coroutine

type EventData {
    Base()
}

record Event(id: String, data: EventData)

type Trail {
    Terminated()
    Single(event: String, res: EventData => Unit at {})
    ParOr(firstTrail: Trail, secondTrail: Trail)
    ParAnd(firstTrail: Trail, secondTrail: Trail)
}

effect Wait {
    def wait(event: String): EventData 
}

def single{trail: => Unit / {Wait}}: Coroutine[Event] = {
    var t = Done()
    try {
        region TrailRegion trail()
    } with Wait {
        def wait(event) = region WaitRegion { 
            t = More(
                fun(_event: Event){
                    if(event == _event.id){
                        single{ resume(_event.data) }
                    } else {
                        Done()
                    }
                }
            )
         }
    }
    t
}

def parOr(firstTrail: Coroutine[Event],  secondTrail: Coroutine[Event]): Coroutine[Event] = {
    Tuple2(firstTrail, secondTrail) match {
        case Tuple2(Done(), t) => Done()
        case Tuple2(t, Done()) => Done()
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event){
                parOr(f1(event), f2(event))
            }
        ) 
    }
}

def parAnd(firstTrail: Coroutine[Event], secondTrail: Coroutine[Event]): Coroutine[Event] = {
   Tuple2(firstTrail, secondTrail) match {
        case Tuple2(Done(), Done()) => Done()
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event){
                parAnd(f1(event), f2(event))
            }
        ) 
    }
}

def eventLoop(t: Coroutine[Event]) : Unit / {} = {
    extern io def nextIteration[A]{f: => A }: Unit = "setTimeout(f, 0)"

    var eventQueue: Dequeue[Event] = emptyQueue()
    
    var trail = t;
        
    def helper(): Unit = {
    
        if(trail != Done() && not(eventQueue.isEmpty())) {
            var popped = eventQueue.popFront()
            popped match {
                case None() => ()
                case Some((e, q)) => 
                    eventQueue = q;
                    trail match {
                        case Done() => ()
                        case More(f) => trail = f(e)
                    }
                }
            nextIteration{helper()}
        }
    }
    helper()    
}

def main() = {
    ()
}