// Was wird gebraucht:
// Eine Umgebung, die ein Event feuern kann.
// Ein Eventlistener, der bemerkt, wenn ein Event passiert
// Ein EventHandler, der das Event bearbeitet.

// Fragen:
// Wie soll der Hardware Interrupt für zum Beispiel "Press Button" implementiert werden?
// -> Eine await/wait muss dann eine Callback/Effekt funktion bei der Umgebung hinterlegen. Wie ?


// Fragen über Effekt:
// - while true mit println produziert ein memory overflow.
// - import io/args funktioniert nicht
// - import immutable/Array importiert toList nicht importiert. Warum?
import immutable/list

type Option[A] {
  Present(value: A);
  Absent()
}

effect Wait {
    def wait(event: String): Unit
}

effect Emit {
    def emit(event: String): Unit
}

// @param trails: A Tuple of internal events and a list of callbacks
def eventHandler (trails: Tuple2[List[String], Option[String => Boolean at {io}]])  = {
   var callback: Option[String => Boolean at {io}] = trails.second
   var events: List[String] = trails.first
   var handling = true

   while(handling){
        callback match {
            case Absent()    => handling = false
            case Present(fn) => 
                 events.foreach {
                    (event: String) => if(fn(event)){
                                        ()
                                        } 
                                        else{
                                        callback = Absent()
                                        } 
                                } 
        }
    }
}

def single{trail: => Unit / {Wait, Emit}} = {
    var waiting = region WaitingRegion Absent() 
    var internalEvents: List[String] = region internalEventRegion []
    try {
        trail();
    } with Wait {
        def wait(event: String) = region X {
            waiting = Present(fun (emittedEvent: String){
                var isActive = true
                if(emittedEvent == event){
                    resume(())
                    isActive = false      
                }
                isActive
                })
            ()
        }
    } with Emit {
        def emit(event: String) = region Y {
            internalEvents =  internalEvents.append(Cons(event, Nil()))
            resume(())
        }
    }
    
    Tuple2(internalEvents, waiting)
}

def parOr 
    {trail1: => Unit / {Wait, Emit}}
    {trail2: => Unit / {Wait, Emit}} = {

        var single1 = single{trail1};
        var single2 = single{trail2};
        var internalEvents: List[String] = single1.first.append(single2.first);

        def callback(event: String) = {

            if(single1.second(event) && single2.second(event)){
                true
            }else{
                false
            }

        }

    Tuple2(internalEvents, callback)

}


def main() = {
    //Exmaples:
    println("Example 1")
    eventHandler(
        single{
            println("Emitting Event 1")
            do emit("1")
            println("Waiting for Event 1")
            do wait("1")
            println("Event 1 Happened")
        }
    )
    println("Example 2")
    eventHandler(
        parOr 
            {
                println("Trail 1: Wait for Event 1")
                do wait("1")
                println("Trail 2: Emit Event 2")
                do emit("2")
            }
            {
                println("Trail 2: Emit Event 1")
                do emit("1")
                println("Trail 2: Wait for Event 2")
                do wait("2")
            }
    )
}
