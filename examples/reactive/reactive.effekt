module reactive/reactive
import immutable/list
import immutable/dequeue
import immutable/option

type EventData {
    Base()
}

record Event(id: String, data: EventData)

type Coroutine[A] {
    Done()
    More(f: A => Coroutine[A] at {global, io})
}

effect Wait {
    def wait(event: String): EventData 
}

def single(trail: => Unit / {Wait} at {global, io}): Coroutine[Event] = {
    try {
        trail();
        Done()
    } with Wait {
        def wait(event) = {
            //println("handle wait"); 
            More(
                fun(_event: Event){
                    if(event == _event.id){
                        resume(_event.data)
                    } else {
                        Done()
                    }
                   
                }
            )
         }
    }
    
}

def parOr(firstTrail: Coroutine[Event],  secondTrail: Coroutine[Event]): Coroutine[Event] = {
    Tuple2(firstTrail, secondTrail) match {
        case Tuple2(Done(), t) => Done()
        case Tuple2(t, Done()) => Done()
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event){
                parOr(f1(event), f2(event))
            }
        ) 
    }
}

def parAnd(firstTrail: Coroutine[Event], secondTrail: Coroutine[Event]): Coroutine[Event] = {
   Tuple2(firstTrail, secondTrail) match {
        case Tuple2(Done(), Done()) => Done()
        
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event){
                parAnd(f1(event), f2(event))
            }
        )

        case Tuple2(Done(), More(f)) => More(
            fun(event: Event){
                parAnd(Done(), f(event))
            }
        )

        case Tuple2(More(f), Done()) => More(
            fun(event: Event){
                parAnd(f(event), Done() )
            }
        )
    }
}

extern io def nextIteration[A]{f: => A}: Unit = "setTimeout(() => f().run(), 0)"

def eventLoop (trail: Coroutine[Event], poll: => Dequeue[Event] at {}): Unit / {} = region Event {
    //var x in EventLoop = 
    if(trail != Done()) {
       poll().popFront() match {
       case None() => nextIteration{eventLoop(trail, poll)}
       case Some((e, q)) 
         => trail match {
                    case Done()  => ()
                    case More(f) => nextIteration{eventLoop(f(e), poll)}
            }
        }
    }
    ()
}

