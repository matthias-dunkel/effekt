module reactive/reactive
import immutable/list
import immutable/dequeue
import immutable/option

type EventData {
    Base()
    StringData(data: String)
    IntData(data: Int)
}

def isBaseData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def isStringData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def isIntData(event: EventData): Boolean = event match {
    case IntData(d) => true
    case ev => false
}

extern pure def JStoString(number: Int): String = "toString(number)"
def unsafeToString(event: EventData): String = event match {
    case StringData(d) => d
    case ev => ""
}

extern pure def JSparseInt(string: String): Int = "parseInt(string)"

def unsafeToInt(event: EventData): Int = event match {
    case IntData(d) => d
    case StringData(d) => JSparseInt(d)
    case ev => 0
}

record Event(id: String, data: EventData)

type Coroutine[A] {
    Done()
    More(f: (A, Coroutine[A]) => Coroutine[A] at {global, io})
}

effect Wait {
    def wait(event: String): EventData 
}

effect Poll {
    def poll(): Dequeue[Event]
}

effect Tick {
    def nextTick(): Unit
}

def single (trail: => Unit / { Wait } at {global, io}): Coroutine[Event] = {
    try {
        trail()
        Done()
    } with Wait {
        def wait(event) = {
            More(
                fun(_event: Event, before: Coroutine[Event]){
                    if(event == _event.id){
                        resume(_event.data)
                    } else {
                        before
                    }
                }
            )
         } 
    }
}

def parOr(firstTrail: Coroutine[Event],  secondTrail: Coroutine[Event]): Coroutine[Event] = {
    Tuple2(firstTrail, secondTrail) match {
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event, before: Coroutine[Event]){
                parOr(f1(event, More(f1)), f2(event, More(f2)))
            }
        )
        case Tuple2(t1, t2) => Done() 
    }
    
}

def parAnd(firstTrail: Coroutine[Event], secondTrail: Coroutine[Event]): Coroutine[Event] = {
   Tuple2(firstTrail, secondTrail) match {
        case Tuple2(Done(), Done()) => Done()
        
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event, before: Coroutine[Event]){
                parAnd(f1(event, More(f1)), f2(event, More(f2)))
            }
        )

        case Tuple2(Done(), More(f)) => More(
            fun(event: Event, before: Coroutine[Event]){
                parAnd(Done(), f(event, More(f)))
            }
        )

        case Tuple2(More(f), Done()) => More(
            fun(event: Event, before: Coroutine[Event]){
                parAnd(f(event, More(f)), Done() )
            }
        )
    }
}

def eventLoop (trail: Coroutine[Event]): Unit / {Tick, Poll} = {
    var t = trail
    while(t != Done()){
        var q = do poll();
        while(not(q.isEmpty())) {
            q.popFront() match {
                case None() => ()
                case Some((e, q1)) => 
                    q = q1;
                    t match {
                        case Done() => ()
                        case More(f) => t = f(e, More(f))
                    }
            }
        }
        do nextTick()
    }
}

def finalize{f: => Unit / {Poll, Tick}} = {
    try {
        f()
    } with Poll {
        def poll() = resume(emptyQueue())
    } with Tick {
        def nextTick() = resume(())
    }
}

effect InternalEvent{
    def instant(): String
}

def withInternalEnv{ f: => Unit / {Poll, Tick, InternalEvent} } = {
    println("withInternalENv: Not completely implemented")
    var queue = emptyQueue()
    try {
        f()
    } with Poll {
        def poll() = resume(queue)
    } with Tick {
        def nextTick() = resume(())
    } with  InternalEvent {
        def instant() = {
                queue = queue.pushBack(Event("instant", Base()))
                resume("instant")
            }
    }
}
