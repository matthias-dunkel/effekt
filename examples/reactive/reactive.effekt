module reactive/reactive
import immutable/list
import immutable/dequeue
import immutable/option

type EventData {
    Base()
    StringData(data: String)
    IntData(data: Int)
}

def isBaseData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def isStringData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def isIntData(event: EventData): Boolean = event match {
    case StringData(d) => true
    case ev => false
}

def unsafeToString(event: EventData): String = event match {
    case StringData(d) => d
    case ev => ""
}

def unsafeToInt(event: EventData): Int = event match {
    case IntData(d) => d
    case ev => 0
}

record Event(id: String, data: EventData)

type Coroutine[A] {
    Done()
    More(f: (A, Coroutine[A]) => Coroutine[A] at {global, io})
}

effect Wait {
    def wait(event: String): EventData 
}

def single(trail: => Unit / {Wait} at {global, io}): Coroutine[Event] = {
    try {
        trail();
        Done()
    } with Wait {
        def wait(event) = {
            More(
                fun(_event: Event, before: Coroutine[Event]){
                    if(event == _event.id){
                        resume(_event.data)
                    }else{
                        before
                    }
                }
            )
         } 
    }
}

def parOr(firstTrail: Coroutine[Event],  secondTrail: Coroutine[Event]): Coroutine[Event] = {
    Tuple2(firstTrail, secondTrail) match {
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event, before: Coroutine[Event]){
                parOr(f1(event, More(f1)), f2(event, More(f2)))
            }
        )
        case Tuple2(t1, t2) => Done() 
    }
    
}

def parAnd(firstTrail: Coroutine[Event], secondTrail: Coroutine[Event]): Coroutine[Event] = {
   Tuple2(firstTrail, secondTrail) match {
        case Tuple2(Done(), Done()) => Done()
        
        case Tuple2(More(f1), More(f2)) => More(
            fun(event: Event, before: Coroutine[Event]){
                parAnd(f1(event, More(f1)), f2(event, More(f2)))
            }
        )

        case Tuple2(Done(), More(f)) => More(
            fun(event: Event, before: Coroutine[Event]){
                parAnd(Done(), f(event, More(f)))
            }
        )

        case Tuple2(More(f), Done()) => More(
            fun(event: Event, before: Coroutine[Event]){
                parAnd(f(event, More(f)), Done() )
            }
        )
    }
}

extern io def nextIteration[A]{f: => A}: Unit = "setTimeout(() => f().run(), 0)"

def eventLoop (trail: Coroutine[Event], poll: => Dequeue[Event] at {}): Unit / {} = {
    if(trail != Done()) {
       poll().popFront() match {
       case None() => nextIteration{eventLoop(trail, poll)}
       case Some((e, q)) 
         => trail match {
                    case Done()  => ()
                    case More(f) => nextIteration{eventLoop(f(e, More(f)), poll)}
            }
        }
    }
    ()
}

