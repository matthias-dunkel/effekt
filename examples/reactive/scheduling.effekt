module reactive/interleave

import immutable/option
import reactive/types
import reactive/effects
import reactive/asyncTask

def bothAreDone[T1, T2] {task1: => T1 / Scheduling} {task2: => T2 / Scheduling}: Tuple2[T1, T2]  / Scheduling = {
    var p1 = fun(){()}
    var p2 = fun(){()}
    var r1 = None()
    var r2 = None()

    p1 = fun(){
        try {
            r1 = Some(asyncTask{task1()})
        } with Scheduling {
            def tick() = { p1 = fun(){resume(())}}
        }
    }

    p2 = fun(){
        try{
            r2 = Some(asyncTask{task2()})
        } with Scheduling {
            def tick() = { p2 = fun(){resume(())} }
        }
    }

    def loop(): Tuple2[T1, T2] = {
        r1 match {
            case None() => r2 match {
                    case None() => p1(); p2(); do tick(); loop()
                    case Some(d) => p1(); do tick(); loop()
                }
    
            case Some(d1) => r2 match {
                case None() => p2(); do tick(); loop()
                case Some(d2) => Tuple2(d1, d2)
            }
        }
    }

    loop()
}


def oneIsDone[T1, T2]{ task1: => T1 / Scheduling } {task2: => T2 / Scheduling }: Either[T1, T2] / Scheduling = {
    var p1 = fun(){()}
    var p2 = fun(){()}
    var r1 = None()
    var r2 = None()

    p1 = fun(){
        try {
            r1 = Some( task1() )
        } with Scheduling {
            def tick() = { p1 = fun(){ resume(()) }}
        }
    }

    p2 = fun(){
            try {
            r2 = Some(asyncTask{task2()})
        } with Scheduling {
            def tick() = { p2 = fun(){ resume(())} }
        }
    }

    def loop(): Either[T1, T2] = {
        p1();
        r1 match {
            case Some(d1) => Left(d1)
            case None() => 
                p2();
                r2 match {
                    case Some(d2) => Right(d2)
                    case None() =>  do tick(); loop()
                }
        }
    }
    loop()
}

def forever[T] { task: => T / Scheduling }: Nothing / Scheduling = try {
    task()
    forever { task }
} with Scheduling {
    def tick() = { do tick(); resume(())}
} 

def run[T]{task: => T / { Scheduling }}: T = {
    try{
        task()
    } with Scheduling {
       def tick() = resume(())
    }
}
